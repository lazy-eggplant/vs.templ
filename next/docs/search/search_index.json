{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Some features are still missing, and are tracked on the repo.  Documentation is an ongoing effort, so you will not find everything well described.  Contributions to make them better are very welcome.</p> <p><code>vs-templ</code> is a simple preprocessor for XML files. It can be used to statically generate new files from a template definition and a data source. Static templates can be seen as extremely simple programs serialized in XML which are interpreted by this preprocessor. They consume input data (also XML) to generated output XML.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-not-using-xslt","title":"Why not using XSLT?","text":"<p><code>vs-templ</code> was first developed in the context of vs to express static, yet parametric, components. While the XML ecosystem is often reliant on XSLT as a preprocessor, this option was quickly dismissed in the parent project for several reasons:</p> <ul> <li>The rest of the <code>vs</code> is based on <code>pugixml</code>. The only lightweight XSLT 1.0 implementation which is decently licensed is libxslt based on libxml2.   Because of that, a trivial integration would have been quite wasteful: an additional serialization and parsing stage is needed to move the tree structure between libraries.</li> <li>The scope of XSLT, even in its very first version was excessive &amp; its syntax just verbose. This is mostly a result of <code>xpath</code> being too powerful of a tool.</li> <li>At some point <code>vs</code> will come with dynamic native components, and the idea is for them to match in syntax and behaviour the extended tags introduced by this preprocessor. A custom implementation is the only way to ensure a seamless integration between the two.</li> </ul> <p>Hence, <code>vs</code> vendors vs.templ its own XSLT-ish preprocessor. Still, nothing about its semantics or syntax is directly tied to <code>vs</code>, so I am distributing it as a separate package, hoping it can reach a wider adoption.</p>"},{"location":"faq/#why-not-handlebars-or-mustache","title":"Why not handlebars or mustache?","text":"<p>This class of templating solutions cannot understand XML. As such, the resulting generation will not ensure something syntactically correct is generated.</p>"},{"location":"faq/#is-there-a-sax-implementation","title":"Is there a SAX implementation?","text":"<p>No, there is not. Some features don\u2019t strictly require a DOM, but they don\u2019t really translate well in terms of a pull parser. The memory peak usage would not be much better either for most reasonable templates, so there is no real incentive to implement this preprocessor based on a different backend for now. If one needs to access data sources with thousands or millions of entries before processing and setting the window of interest, external sources are the right approach, and they are fully supported. That way, there is no need to load the entire data source in memory as it would happen with an XML file.</p>"},{"location":"faq/#can-we-support-other-input-formats-for-the-dataset","title":"Can we support other input formats for the dataset?","text":"<p>In theory, it would be possible for data to be expressed in other formats (eg. JSON) as well, but at the moment this is not a supported feature and is not likely going to be in scope for quite a while. For the time being, you can offer external data sources of whatever type by implementing the optional <code>loadfn</code> downstream. This allows vs.templ to indirectly work with any data source you desire.</p>"},{"location":"for-developers/","title":"Information for developers","text":""},{"location":"for-developers/#building","title":"Building","text":"<ul> <li>A modern C++ toolchain supporting C++20</li> <li><code>meson</code> as the build system of choice</li> <li><code>pandoc</code> (optional) if you want to generate the documentation/man pages</li> <li><code>gperf</code> (optional) if you want to regenerate the command dispatchers not in use right now, when frozen will be removed this is its replacement.</li> <li><code>valgrind</code> (optional) to run some tests</li> </ul> <p>To build, test and install it you can just use normal meson commands like.</p> <pre><code>meson setup build\nmeson compile -C build\nmeson install -C build\n</code></pre>"},{"location":"for-developers/#embedding-it","title":"Embedding it","text":"<p>At this time, this repository is only available as a meson package. I might consider adding <code>cmake</code> later on to gain a wider compatibility.</p> <p>If <code>pugixml</code> is already provided as a dependency in the main project, that will be used.</p> <p>vs.templ requires you implement some features downstream to support all features. If not provided, the library will still be usable, but the command tags <code>include</code> and <code>data</code> will not work as expected. The CLI in <code>src/app</code> shows everything that is needed to use vs.templ as a library.</p>"},{"location":"for-developers/#c-bindings","title":"C bindings","text":"<p>At this time, no C bindings are provided. My downstream project needs not them, and pugixml is C++ only. Still, the public interface of this library is quite thin, so they can be easily introduced if so desired.</p>"},{"location":"for-developers/#versioning","title":"Versioning","text":"<p>Releases are tagged on the repo, with <code>master</code> as the main development branch. Semantic versioning will be followed after <code>v1.0.0</code>. Before that, any release can and will have breaking changes.</p> <p>Versions ending with an odd revision number are meant for proper for releases, while even numbers are only for in-dev stages.</p>"},{"location":"manual/","title":"User Manual","text":"<p><code>vs-templ</code> is a simple preprocessor for XML files. It can be used statically generate new files from a template definition. Static templates can be seen as extremely simple programs which are interpreted by this preprocessor. They consume input data also formatted as XML, and generate some output XML file. In theory, it is possible for data to be expressed in other formats (e.g. JSON) as well, but at the moment this is not a supported feature.</p>"},{"location":"manual/#cli","title":"CLI","text":"<pre><code>vs.tmpl &lt;template-file&gt; &lt;data-file&gt; [namespace=`s:`]\n</code></pre> <p>Unlike its usage in <code>vs.fltk</code>, template must be specified on its own, as it cannot be inferred form a request in the data file.</p> <p>There is also an alternative format:</p> <pre><code>vs.tmpl [namespace=`s:`]\n</code></pre> <p>with both files added via pipes, like <code>vs.tmpl &lt;(cat template.xml) &lt;(cat data.xml)</code></p>"},{"location":"manual/#syntax-quick-reference","title":"Syntax quick reference","text":"<p>vs.templ uses special elements and attributes to determine the actions to be performed by the preprocessor. They are scoped under the namespace <code>s</code>, or any custom defined one. This man page only covers a quick syntax reference. If you are looking for the full specs, please check the official repository.</p> <p>TODO: write cheat sheet of syntax here.</p>"},{"location":"repl-vm/","title":"Computing expressions","text":"<p>Warning</p> <p>This document was originally just a draft to keep as reference while implementing the RPN vm.  As such, its content does not fully represent features has they have been implemented.  Also, some functions reported as not implemented will never be, or some are yet to report.</p> <p>Tentative specs for higher order expressions to add some degree of freedom in calculations. They are still interpreted as expression, starting with <code>:</code>. The content of the expression represent the serialization of a program in reverse polish notation (RPN). The VM is going to run it, and the only element left on stack is taken as the final expression value.</p> <p>For example, assuming the environment had <code>i</code> set to <code>1</code>:</p> <pre><code>: `{i}` `#name-` cat:*`\n</code></pre> <p>will return an expression of type string embedding the value <code>name-1</code>.</p> <p>Type casting must generally be explicit, but some operators might have automatic casting to simplify code. The delimiters are needed, since some types of expressions like strings can contain spaces and other escaping characters. The character <code>|</code> should never be used as it interfere with the serialization of tuples used by vs.templ. Escaping sequences are defined for ` and <code>|</code> as well.</p>"},{"location":"repl-vm/#design","title":"Design","text":""},{"location":"repl-vm/#why-rpn","title":"Why RPN?","text":"<p>Several reasons:</p> <ul> <li>to avoid a complex parser for what will end up being a quite marginal feature</li> <li>it avoids the arbitrary precedence rules usually associated with algebraic operator</li> <li>to be fast and easy to compile into native code if so desired (but for now a vm is all we need)</li> </ul>"},{"location":"repl-vm/#possible-extensions","title":"Possible extensions","text":"<p>I will probably allow braces as NOP operators, just as syntax sugar to improve readability. At some point they could get validated in LSP, so that potential bugs are highlit.</p>"},{"location":"repl-vm/#options-for-implementation","title":"Options for implementation","text":"<p>Assumption: these programs are very short. As such their source is not read in streaming, but it is all resident in memory while compiling. This allows the usage of <code>string_views</code> and the buffer itself in place of allocating too many temporary objects in memory. Hence, processing these expressions should be very memory efficient.</p> <ul> <li>Add the vm to this repo directly.</li> <li>Build a generic vm library for which specific instances can be generated downstream of a schema.   This way it is easier to build different backends and integrate fast dispatching via perfect minimal hashing functions.</li> <li>Find a library already implementing this design and use that. no success in that</li> </ul>"},{"location":"repl-vm/#operators","title":"Operators","text":""},{"location":"repl-vm/#generic","title":"Generic","text":"<ul> <li> <code>dup</code> duplicate the last element on stack</li> <li> <code>nop</code> no operation</li> <li> <code>rem</code> remove last n elements from stack</li> <li> <code>swap</code> swap the two top elements</li> <li> <code>log</code> to log errors/warning etc somewhere</li> </ul>"},{"location":"repl-vm/#string-operators","title":"String operators","text":"<ul> <li> <code>cat</code> <code>[container] cat</code>, simplified version of <code>V</code> where based on the type, the 0 is used as initial and the reducer is the natural <code>+</code> operation</li> <li> <code>join</code> to join together strings on the stack with the first string.</li> <li> <code>rcat</code> like cat but in reverse order</li> <li> <code>rjoin</code> like join but in reverse order</li> <li> <code>esc</code> escape number to string literal</li> </ul>"},{"location":"repl-vm/#boolean-operators","title":"Boolean operators","text":"<p>Boolean types are not directly supported. They are just integers with extra semantic.</p> <ul> <li> <code>if</code> <code>[false] [true] [condition] ?</code></li> <li> <code>and</code> <code>or</code> <code>not</code> as expected (they are bitwise)</li> <li> <code>xor</code> <code>nor</code> <code>nand</code> as expected (they are bitwise).</li> <li> <code>true</code> <code>false</code> to load those values in stack.</li> </ul>"},{"location":"repl-vm/#comparison-operators","title":"Comparison operators","text":"<ul> <li> <code>eq</code> <code>neq</code> <code>bg</code> <code>bge</code> <code>lt</code> <code>lte</code> for integers &amp; floats</li> <li> For strings we have at least three criteria, which is making these operations harder to handle<ul> <li> Typical comparison based on lexicographic comparison</li> <li> Dot comparison, introduced by <code>vs</code> to handle nesting</li> <li> Natural comparison, where for example $20&lt;100$</li> </ul> </li> </ul>"},{"location":"repl-vm/#common-algebraic-operators","title":"Common algebraic operators","text":"<p>And all the typical maths operations as usual</p> <ul> <li> <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>mod</code> (and mnemonic versions too)</li> <li> <code>pow</code> <code>log</code></li> <li> <code>count.0</code> &amp; <code>count.1</code></li> </ul>"},{"location":"repl-vm/#cast","title":"Cast","text":"<ul> <li> <code>as.str</code></li> <li> <code>as.int</code></li> <li> <code>as.float</code></li> <li> <code>as.bool</code></li> </ul>"},{"location":"repl-vm/#special","title":"Special","text":"<ul> <li> <code>PIPE</code> and <code>APOS</code> to escape <code>|</code> and ``` respectively</li> <li> <code>(</code> &amp; <code>)</code> as nop just to enable formatting in expression (not enforced, but the LSP might check)</li> <li> <code>rem</code> to tag the prior tag as comment (remove the last element from stack)</li> </ul>"},{"location":"sorting/","title":"Sorting","text":"<p>Sorting criteria are used in two situations:</p> <ul> <li>in the <code>order-by</code> attributes of cycles, supported by all of them in some way except for <code>for-range</code></li> <li>as basic boolean binary operator in the RPN virtual machine</li> </ul> <p>The two implementations are not unified, so feature parity is desirable but not intrinsic.</p>"},{"location":"sorting/#ordering-method","title":"Ordering method","text":""},{"location":"sorting/#asc-desc","title":"<code>ASC</code> &amp; <code>DESC</code>","text":"<p>Whatever ordinal is assigned to the entries, sorting is just based on an ascending or descending order.</p>"},{"location":"sorting/#random","title":"<code>RANDOM</code>","text":"<p>Data of any type is first hashed, and <code>asc</code> is applied to those hashes. For integers, floats and booleans this just involves their immediate data. For strings the characters buffer is used as the hash source. If the dot notation is needed, each token separated by <code>.</code> will be hashed and compared on its own. Nodes should not be directly compared. Doing so is not illegal, just nonsensical.</p>"},{"location":"sorting/#comparison-operators-for-supported-types","title":"Comparison operators for supported types.","text":""},{"location":"sorting/#nodes","title":"Nodes","text":"<p>Via suffix <code>:n</code> or <code>:node</code>. Nodes should not be directly compared. Doing so is not illegal, just nonsensical and UB. A more precise semantic for this case might be introduced later on.</p>"},{"location":"sorting/#attributes","title":"Attributes","text":"<p>They are always cast to string before evaluation. So they will not be compared as XML nodes.</p>"},{"location":"sorting/#integers","title":"Integers","text":"<p>Via suffix <code>:i</code>, <code>:int</code> or <code>:integer</code>. Comparison as expected from any basic math class.</p>"},{"location":"sorting/#floats","title":"Floats","text":"<p>Via suffix <code>:f</code>, `:float``. Comparison as expected from any basic math class.</p>"},{"location":"sorting/#booleans","title":"Booleans","text":"<p>Via suffix <code>:b</code>, <code>:bool</code> or <code>:boolean</code>. <code>true</code> is smaller than <code>false</code>.</p>"},{"location":"sorting/#strings","title":"Strings","text":"<p>Strings are by far the most complex to handle as multiple criteria are possible.</p>"},{"location":"sorting/#encoding-ordering","title":"Encoding ordering","text":"<p>Via suffix <code>:s</code>, <code>:str</code> or <code>:string</code>. Based on the binary representation of UTF-8 encoding.</p>"},{"location":"sorting/#natural-ordering","title":"Natural ordering","text":"<p>Via suffix <code>:ns</code>, <code>:natstr</code> or <code>:natural-string</code>. <code>hello10</code> bigger than <code>hello2</code>.</p>"},{"location":"sorting/#lexicographic-ordering","title":"Lexicographic ordering","text":"<p>Via suffix <code>:ls</code>, <code>:lexistr</code> or <code>:lexi-string</code>. For symbols in the Latin alphabet this is more or less equivalent to the encoding ordering. However, different languages have totally different customary approaches, and are not often based on alphabets. Basically any criteria rooted in linguistic arguments goes in here.</p>"},{"location":"syntax/","title":"Full Syntax reference","text":"<p>Warning</p> <p>While all core features have been implemented, documentation efforts are still ongoing.</p> <p>vs.templ uses special elements and attributes to define actions for the preprocessor to perform. These XML entities are scoped with the prefix determined by the URI vs.templ. Conventionally, the prefix used is <code>s</code>, but users can set up their own. Please, notice that pugixml, on which vs.templ is based, does not have a full understanding of XML, and namespaces are in the list of features not covered. As such, this preprocessor will not really perform any actual validation, if not for its own prefix.</p>"},{"location":"syntax/#expressions","title":"Expressions","text":"<p>Most of the attributes introduced by vs.templ accept expressions, and not just simple literal values. Expression can are used to access elements and attributes from the data source, or they can represent native types like integers, floats and strings. Their definition and usage is purposefully restricted, to prevent the execution of arbitrary code. This is a full list of all expression types:</p> <ul> <li>Empty expression, a pseudo-value often used to represent errors</li> <li>String, automatically assigned from expressions starting with <code>#</code> (the prefix <code>#</code> is skipped and not part of the final string)</li> <li>Integers (base 10), automatically assigned from expressions starting with a digit, <code>+</code>, <code>-</code> or <code>.</code></li> <li>Floating point numbers, like integers but always ending with <code>f</code></li> <li>Paths, of which few forms exists:<ul> <li>Paths with arbitrary prefix <code>{var-name}</code> where <code>var-name</code>is searched for and resolved from the symbols\u2019 stack. They can only appear as the first token.</li> <li>Those starting with <code>$</code>. This special symbol is used to mark the nearest recorded node from the data XML being visited, or root if none. It is a shorthand for <code>{$}</code>.</li> <li>Absolute paths starting from the root, with prefix <code>/</code>.</li> <li>Paths starting with <code>~</code>, an attribute rooted on <code>{$}</code>.</li> </ul> </li> </ul> <p>Path expressions will continue with one or more tokens <code>/</code>-terminated representing the tag name being visited. If terminated with <code>~prop-name</code> the relevant attribute is selected. There are also two special meta-properties which can be accessed this way:</p> <ul> <li>Special access to the property<code>~!txt</code> to get the node text.</li> <li>Special access to the element\u2019s name via <code>~!tag</code></li> </ul> <p>Finally, there are stack meta-expressions, starting with <code>:</code>. Those are run by a stack VM and can be sparingly used to perform more complex tasks. They return a single expression in one of the other real types. The full specifications of these meta-expressions can be found here. For most scenarios, only a minor subset is going to be useful, like some basic integer maths, comparisons and <code>cat</code> to merge strings.</p> <p>No further combination or format is allowed in expression. Else, their parsing will fail. However, the preprocessor will not generally throw exceptions, the preferred mechanism is to emit log messages and continue.</p>"},{"location":"syntax/#examples","title":"Examples","text":"<p>Using the following XML file as reference:</p> <pre><code>&lt;hello&gt;\n    &lt;world attribute-a=\"value-0\"&gt;\n        text-0\n    &lt;/world&gt;\n    &lt;!-- The second one will never be visited with paths like /hello/world/--&gt;\n    &lt;world attribute-a=\"value-1\"&gt;\n        text-1\n    &lt;/world&gt;\n&lt;/hello&gt;\n</code></pre> <ul> <li><code>/hello/world/</code> is the list of children for the first <code>world</code> element in <code>hello</code></li> <li><code>/hello/world~attribute-a</code> is evaluated as <code>value-0</code></li> <li><code>/hello/world~!txt</code> is evaluated as <code>text-0</code></li> <li>Assuming a for cycle in <code>/hello/</code>, its children will be navigated and <code>$~attribute-a</code> will be resolved in <code>value-0</code> and <code>value-1</code>.</li> </ul>"},{"location":"syntax/#element-based-operators","title":"Element-based operators","text":"<p>Element operators or tag operators are special elements either acting on their children or they use them as default value in case of failure. There are several to control flow or add content to the final document.</p>"},{"location":"syntax/#value","title":"<code>value</code>","text":"<p>To introduce the result of a (meta) expression in the tree. Integers and floats are automatically serialized before adding them to the page. strings are just appended. attributes are interpreted as strings. nodes are added as subtree.</p> <p><code>value</code> accepts an expression <code>src</code> as argument, by default set to <code>$</code>. If the expression fails, its body will be used instead.</p>"},{"location":"syntax/#examples_1","title":"Examples","text":"<pre><code>&lt;s:value src=\":...\"&gt;This fails, so this text will be used&lt;/s:value&gt;\n&lt;s:value src=\": `1` `2` +\"&gt;Since the operation is ok and returns `3` as integer, this text will not show up&lt;/s:value&gt;\n</code></pre>"},{"location":"syntax/#element","title":"element","text":"<p>This command is usedto generate a new element whose type is by an expression passed via the attribute <code>s:type</code> (this one is specifically namespaced). Any other property and child will be preserved.</p> <p>In case of failure, the tag is dropped.</p>"},{"location":"syntax/#examples_2","title":"Examples","text":"<pre><code>&lt;s:element s:type=\"#tag-name\" prop-1=\"Hello\"&gt;Content&lt;/s:element&gt;\n&lt;s:element s:type=\":\" prop-1=\"Hello\"&gt;This will not be shown as the expression is not valid&lt;/s:element&gt;\n</code></pre>"},{"location":"syntax/#for-range","title":"for-range","text":"<ul> <li><code>tag</code> is the name of the symbol where the current value will be stored. If empty the default <code>$</code> is used.</li> <li><code>from</code> starting value.</li> <li><code>to</code> final value.</li> <li><code>step</code> step of increment. It can be negative. If so <code>to&lt;from</code> must hold true.</li> </ul> <p>Infinite cycles are detected before execution, in which case no step will run. Unlike other <code>for</code> variants, there is no header, footer or empty child. Anything inside a <code>for-range</code> is interpreted as <code>item</code>.</p>"},{"location":"syntax/#example","title":"Example","text":"<pre><code>&lt;s:for-range tag=\"i\" from=\"0\" to=\"10\" step=\"1\"&gt;\n    &lt;s:for-range tag=\"j\" from=\"0\" to=\": `{i}`\" step=\"1\"&gt;\n        &lt;s:value src=\": `{j}` `{i}` mul\" /&gt;\n    &lt;/s:for-range&gt;\n&lt;/s:for-range&gt;\n</code></pre>"},{"location":"syntax/#for-for-props","title":"for &amp; for-props","text":"<p>To iterate over children and props of an element respectively. Aside from that, they mostly share the same interface.</p> <ul> <li><code>tag</code>: the name of the symbol hosting the current XML node pointer. If left empty, its default is assumed to be <code>$</code></li> <li><code>in</code>: must be specified and is a path expression</li> <li><code>filter</code>: as an expression in the internal custom language.</li> <li><code>sort-by</code>: (only available for <code>for</code>) list of <code>|</code> separated path expressions. Elements will be sorted giving priority from left to right</li> <li><code>order-by</code>: order preference for each field in the <code>sort-by</code> or the only one implicit for <code>for-props</code>.   Each entry is a pair <code>type:comparator</code> with type either <code>ASC</code>, <code>DESC</code> or <code>RANDOM</code>.   If not provided, comparator is assumed to be the default one.   As an alternative comparator we could have a one using <code>.</code> to separate values in tokens, and order them token by token.</li> <li><code>limit</code>: maximum number of entries to be iterated. If 0 all of them will be considered, if positive that or the maximum number, if negative all but that number if possible o no content.</li> <li><code>offset</code>: offset from start (of the filtered and ordered list of children)</li> </ul> <p>Both <code>for</code> &amp; <code>for-props</code> support the following list of children. You can use as many instances of the same type as you want, they will be applied to the final document in the order they appear.</p> <ul> <li><code>header</code>: shown at the top of a non-empty container</li> <li><code>footer</code>: shown at the bottom of a non-empty container</li> <li><code>empty</code>: shown if a container is empty</li> <li><code>item</code>: the main body</li> <li><code>error</code>: shown if it was not possible to retrieve items (because of an error in the path for example; in case of empty lists <code>empty</code> is used)</li> </ul> <p>The symbol <code>[tag].c</code> gets loaded with the entry number we are iterating over, so that it is possible to count which one we are at. For <code>for-props</code> there are also <code>[tag].k</code> and <code>[tag].v</code> for key and value of the prop. <code>[tag]</code> by default is <code>$</code>.</p>"},{"location":"syntax/#test-case","title":"test &amp; case","text":"<p>To perform conditional cut and paste in the final tree based on simple matches between a reference expression and some values. Inside the body of <code>test</code> we have one or more <code>case</code>. Attributes for <code>case</code>:</p> <ul> <li><code>continue</code> default is <code>false</code>. If <code>true</code> it continues checking and executing even after a match. Else it will break.</li> <li><code>when</code> an expression to compare against.</li> </ul> <p>The order of <code>case</code> elements is important and determines the overall flow.</p>"},{"location":"syntax/#log","title":"log","text":"<p>Optional argument <code>type</code> set to:</p> <ul> <li><code>notify</code> when something should be logged, but there is no fault or suspicious behaviour ongoing.</li> <li><code>ok</code> for tasks completed successfully</li> <li><code>error</code> when a condition prevents this activity from succeeding, but the situation is recoverable</li> <li><code>warning</code> when something can complete, but it is suspicious.</li> <li><code>panic</code> when an error triggered, and the situation cannot be recovered</li> </ul> <p>Panic does not mean exceptions. For example, the evaluation of an expression might panic, but this problem is not propagated. It just means that there is no way to recover it, and downstream code will have to live with its failure. Error means that there is a capability recognized when it was raised for the system to rectify this issue. For example the inclusion of a file which does not exist can adopt the content of the <code>include</code> tag as fallback.</p>"},{"location":"syntax/#include","title":"include","text":"<p>Important</p> <p>The full behaviour of this function is determined by downstream integration.</p> <p>Add in place the file defined in <code>src</code>. If not found, it uses the content inside <code>include</code>. External files will have their root removed when included. File loading for a single <code>include</code> instance appearing in code is only done once, even if in a cycle. Later requests will show the same content as before. <code>src</code> is just a static string, not an expression. This is because the evaluation of the file must be statically resolved.</p> <p>The functionality of <code>include</code> is not provided by vs.templ and requires downstream integration. As such is no caching provided by vs.templ; if you need that, you will have to implement it as part of the load function passed to the preprocessor constructor. Similarly, circular dependencies are not tested. It is up to you to use a load function which ensures they will not occur.</p> <p>The CLI shipping with this library has a very limited implementation which will load files as XML with normal fs paths.</p>"},{"location":"syntax/#examples_3","title":"Examples","text":"<pre><code>&lt;s:include src=\"component.xml\"&gt;\n    &lt;h1&gt;Placeholder title&lt;/h1&gt;\n    &lt;p&gt;This will be used if the import fails. Leave empty if not needed&lt;/p&gt;\n&lt;/s:include&gt;\n</code></pre>"},{"location":"syntax/#data","title":"data","text":"<p>Important</p> <p>The full behaviour of this function is determined by downstream integration.</p> <p>This command loads a data source in memory, and exposes it via a tag name. Any property which is not <code>src</code> and <code>tag</code> will be exposed to the supplier function for parametrization. Data retrieval is not part of vs.templ, so it is up to the downstream implementation to handle it as desired.</p> <p>The CLI shipping with the library will not handle complex features like filtering, sorting etc. The <code>src</code> passed is just being used as a regular fs path.</p>"},{"location":"syntax/#property-based-operators","title":"Property-based operators","text":"<p><code>xxx</code> are used as tags to identify groups under which multiple attributes should be used.</p>"},{"location":"syntax/#forsub-attrxxx-for-propssub-attrxxx","title":"for.SUB-ATTR.xxx &amp; for-props.SUB-ATTR.xxx","text":"<p>As prop, attribute variants of <code>for</code> and <code>for-props</code>. They add attributes/values to the node they are defined within.</p>"},{"location":"syntax/#valuexxx","title":"value.xxx","text":"<p>As for the element version, to introduce the value of an expression as value of a prop <code>xxx</code>.</p>"},{"location":"syntax/#propxxx","title":"prop.xxx","text":"<p>To generate new property whose name and value are determined by the pair passed as value.</p>"},{"location":"syntax/#examples_4","title":"Examples","text":"<pre><code>&lt;tag s:prop.0=\"#hello|#world\" s:prop.1=\"#hallo|#Welt\"/&gt;\n</code></pre>"},{"location":"syntax/#when","title":"when","text":"<p>To test if the current element should be rendered, if and only if the expression is <code>true</code>.</p>"},{"location":"syntax/#examples_5","title":"Examples","text":"<pre><code>&lt;tag s:when=\": false\"&gt;Content will not be shown!&lt;/tag&gt;\n</code></pre>"},{"location":"syntax/#whenxxx","title":"when.xxx","text":"<p>If and only if the condition is true, the prop <code>xxx</code> is added as empty string. Else it is skipped.</p>"},{"location":"releases/v0.3.11/","title":"V0.3.11","text":"<p>There has been much more progress than anticipated, and most features needed to reach <code>v0.4.1</code> have been filled in already. This release is to make sure <code>vs</code> can properly use the newly supported syntax in its code and examples. Subsequent milestones have been rescheduled, and next new branch <code>v0.4.x</code> will be mostly for consolidation, documentation and to incrementally improve the quality of code. As such, I am splitting this release here, leaving the two leftover commands for <code>v0.3.13</code>.</p>"},{"location":"releases/v0.3.11/#new-features","title":"New features","text":"<ul> <li> Introduced <code>include</code> to load more template files. Please, notice that checks to avoid circular dependencies are to be performed externally.</li> <li> All the remaining prop-based commands.<ul> <li> <code>value</code></li> <li> <code>prop</code></li> <li> <code>for</code></li> <li> <code>for-prop</code></li> </ul> </li> <li> Loading the environment of a preprocessor is now possible via <code>load_env</code>.</li> <li> Improved handling of some expressions making them less verbose.</li> <li> Better (and colourful) logging!</li> </ul>"},{"location":"releases/v0.3.11/#bug-fixing","title":"Bug fixing","text":"<ul> <li>Fixed several broken maths operations like <code>*</code>.</li> </ul>"},{"location":"releases/v0.3.11/#breaking-changes","title":"Breaking changes","text":"<p>The interface of <code>preprocessor</code> was changed once again to support the XML loader function. Minimal changes are expected downstream, based on your prior usage.</p>"},{"location":"releases/v0.3.13/","title":"V0.3.13","text":"<p>A new intermediate release before moving to <code>v0.4.x</code>. Surprisingly, whatever was originally scheduled for <code>v0.3.13</code> has been delayed again, and other features took the spot! So, yeah, the attribute version of <code>for-props</code> and <code>for</code> are yet to come (at least they are covered in the examples).</p> <p>The revised plan is for the two missing commands to be in <code>v0.3.15</code>, and then we move straight to the new minor. At that point the development here will slow down as all core features made their way in the codebase. I will be resuming work on <code>vs.fltk</code>.</p>"},{"location":"releases/v0.3.13/#new-features","title":"New features","text":"<ul> <li><code>data</code> command has been added to introduce external data sources in the template.</li> <li><code>random</code> order support in <code>order-by</code> for <code>for</code> loops. Stable random ordering depending on a seed number.</li> <li>Examples! LOTS OF EXAMPLEEES! And improved tests.</li> <li>We now have the most blazingly fast web server based on vs.templ (according to source myself)!</li> </ul>"},{"location":"releases/v0.3.13/#bug-fixes","title":"Bug fixes","text":"<ul> <li><code>test/case</code> fixed to match the intended specs.</li> <li>Fixed behaviour of <code>for-prop</code> tag command to ensure good symbols are provided in the loop scope.</li> <li>Fixed handling of floating point numbers in expressions.</li> </ul>"},{"location":"releases/v0.3.13/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Reverted and fixed <code>src</code> in for cycles to <code>in</code> as it initially was.</li> <li>Changed the preprocessor interface to introduce the new <code>loadfn</code> (the name has been recycled from before, the older <code>loadfn</code> is now <code>includefn</code>)</li> </ul>"},{"location":"releases/v0.3.15/","title":"V0.3.15","text":"<p>All done! The last <code>for</code> and <code>for-props</code> prop based commands have been completed. With this development of functionality for vs.templ is done.</p> <p>There are minor features planned for the <code>v0.4.x</code> branch, but most will be documentation, better examples, formal XML schemas and testing infrastructure. Once that is done we are going straight to <code>v1</code> if there are no architectural problems being discovered in the meanwhile.</p>"},{"location":"releases/v0.3.5/","title":"V0.3.5","text":"<p>Technical release, only for the sake of fully testing workflows.</p> <ul> <li> At least feature parity with what it was its split from vs-fltk.</li> <li> Some degree of documentation.</li> <li> Add support for <code>element.text()</code> &amp; <code>element.name()</code> in query.</li> <li> Replace the current split implementation with something requiring less allocations</li> <li> man page generation via meson (not great, but I\u2019ll take it).</li> <li> Initial setup for the test-suite.</li> <li> Add actual support of dot comparison in strings (to be tested).</li> <li> Functional CLI needed.</li> <li> Install scripts working (testing needed).</li> </ul>"},{"location":"releases/v0.3.7/","title":"V0.3.7","text":"<p>This release brings many new features which further expand the capabilities of vs.templ:</p> <ul> <li> Introduced a more robust logging infrastructure at all levels. Now errors and warnings are better logged.<ul> <li> Introduced <code>log</code> tag</li> </ul> </li> <li> Introduced meta-expressions with their RPN virtual machine to support more complex evaluations.        A good number of operators have been implemented so far, with most of the architectural bits ironed out.</li> <li> Introduced <code>filter</code> for loops now that we have meta-expressions.</li> <li> A significantly improved documentation.</li> <li> Initial work to support prop-based commands.</li> </ul> <p>The <code>in</code> attribute for cycles has been removed in favour of <code>src</code> to make it more consistent. No further breaking change is expected from v0.3.5 for templates, but the public interface itself has. You might need to slightly refactor current code, and provide an explicit logging function. Next release is expected to be the very last for v0.3.x.</p>"},{"location":"releases/v0.3.9/","title":"V0.3.9","text":"<p>Just a quick corrective version over v0.3.7 to fix the behaviour of several untested features, like the newly added filters of <code>for</code> loops. This release also introduces few more meta-expression operators to allow escaping, and a realistic example emitting HTML to complement the rest of the docs.</p>"},{"location":"releases/v0.3.9/#new-features","title":"New features","text":"<ul> <li><code>when</code> as a prop command for the conditional rendering of the owner.</li> </ul>"},{"location":"releases/v0.3.9/#breaking-changes","title":"Breaking changes","text":"<ul> <li><code>sort-by</code> and <code>order-by</code> will now use <code>|</code> in place <code>,</code> to split multiple options.</li> <li><code>when</code>/<code>is</code> fully replaced. The older syntax was dreadful but necessary without the RPN virtual machine, but now that we have\u2026 say hello to <code>test</code>/<code>case</code>.</li> </ul>"},{"location":"releases/v0.4.1/","title":"V0.4.1","text":"<p>This first revision of the new minor has no real incompatibility with the previous one, just some fixes and small new features.</p>"},{"location":"releases/v0.4.1/#new-features","title":"New features","text":"<p>As expected, this update and the next few ones will be light on new features, mostly focusing on documentation, fixes and architectural improvements. Still, using the library for its intended purpose exposed some sharp edges, which will be/have been taken care of. This is what is new in this release:</p> <ul> <li>Centralize <code>symbol</code> comparisons have been extended and centralized in a single function serving the entire code base.</li> <li>Strings will now support ordering based on the dot modifier even when <code>random</code> is used.</li> <li>There is default support for string comparisons in the boolean operators of the RPN. Several fixes have been resolved for the other comparisons as well.</li> <li>A new prop command <code>s:enable.*</code>. It conditionally adds a prop if the condition is true.   This might be reworked in <code>s:when.*</code> as this override does not conflict with the other <code>s:when</code>, but no decision has been taken yet.</li> </ul>"},{"location":"releases/v0.4.1/#fixes","title":"Fixes","text":"<ul> <li>Several conversions are now locale-independent.</li> <li>In the UI for the demo, the generate button is now locked while fetching examples.</li> <li>Many fixes in the docs and demo examples.</li> </ul>"},{"location":"releases/v0.4.3/","title":"V0.4.3","text":"<p>Very minor release, just so that downstream code can take advantage of several fixes and new features. Also, this release restores the WASM/WASI build which broke due to <code>from_chars</code> compatibility across toolchains.</p>"},{"location":"releases/v0.4.3/#new-features","title":"New features","text":"<ul> <li>Natural ordering for strings is now supported in <code>order-by</code> by all commands (as the new default)</li> <li><code>order-by</code> directives can be typed, like <code>asc:float</code> or <code>asc:f</code> will parse entries as float and sort them accordingly.</li> </ul>"},{"location":"releases/v0.4.3/#breaking","title":"Breaking","text":"<ul> <li><code>s:enable.*</code> has been reworked as an overload of <code>s:when</code>. Use it as <code>s:when.*</code>.</li> <li>Default string comparisons are now following natural ordering, which might break things.</li> </ul>"}]}
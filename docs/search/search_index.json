{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TBW","title":"Home"},{"location":"calc/","text":"Tentative specs for the expressions used in: calc its prop variant in filters within for maybe in for-range , replacing simple numbers. My plan is to add a stack-based language in polish notation, constrained to have only one root. For example: add:2 int:2 [{var-a}/path~attribute] error add:2 [2] [3] Compressed it would be something like: + int[{var-a}/path~attribute]! +[2][3] Inside [...] there are path expressions. Type casting should be explicit. The delimiters are needed since expressions can contain spaces and other escaping characters. The reason for going with something like this are: to avoid a complex parser for what will end up being a quite marginal feature to avoid the arbitrary precedence rules usually associated to algebraic operator to be fast and easy to compile into native code via tcc I will probably allow braces, just for the sake of readability. At some point I might validate them if present just to highlight potential bugs. Options for implementation: Add them to this repo directly. Build a schema based generator and use it. This way it is easier to build different backends and integrate fast dispatching via perfect minimal hashing functions. Find a library already implementing this design and use that. Assumption: these programs are very short. As such their source is not read in streaming, but it is all resident in memory while compiling. This allows the usage of string_views and the buffer itself in place of allocating too many temporary objects in memory. Hence, processing these expressions should be very memory efficient. Operators # count [expr] # , count the dimensionality of expression returning a 1-dimensional scalar number reduce [initial] [reducer] [container] V , reduces to a 1-dimensional object each element of the container starting from the initial expression (sum, join etc) filter [container] F , filters elements out of a container map [expr] [container] M , maps container based on a lamba concat [container] cat , simplified version of V where based on the type, the 0 is used as initial and the reducer is the natural + operation if [false] [true] [condition] ? And all the typical math operations as usual","title":"Calc"},{"location":"calc/#operators","text":"count [expr] # , count the dimensionality of expression returning a 1-dimensional scalar number reduce [initial] [reducer] [container] V , reduces to a 1-dimensional object each element of the container starting from the initial expression (sum, join etc) filter [container] F , filters elements out of a container map [expr] [container] M , maps container based on a lamba concat [container] cat , simplified version of V where based on the type, the 0 is used as initial and the reducer is the natural + operation if [false] [true] [condition] ? And all the typical math operations as usual","title":"Operators"},{"location":"faq/","text":"Is there a SAX implementation? # No, there is not. Some features don\u2019t strictly require a DOM, but they don\u2019t really translate well in terms of a pull parser. The memory peak usage would not be much better either for many reasonable templates, so there is no real incentive to implement this preprocessor based on a different backend for now. Still, if you want to do so you are very welcome!","title":"Faq"},{"location":"faq/#is-there-a-sax-implementation","text":"No, there is not. Some features don\u2019t strictly require a DOM, but they don\u2019t really translate well in terms of a pull parser. The memory peak usage would not be much better either for many reasonable templates, so there is no real incentive to implement this preprocessor based on a different backend for now. Still, if you want to do so you are very welcome!","title":"Is there a SAX implementation?"},{"location":"for-developers/","text":"Building # A modern C++ toolchain supporting C++20 meson as the build system of choice pandoc if you want to generate the documentation/man pages To build, test and install it you can just use normal meson commands. Using it # Right now this project is only available as a meson package. I might consider adding cmake later on to gain a wider compatibility. Versioning # At this time, this repository is only available as a meson package. Releases are tagged on the repo, with master as the main development branch. Semantic versioning will be followed after v1.0.0 . Before that, any release can and will have breaking changes. Versions ending with an odd revision number are meant for proper for releases, while even numbers are only for in-dev stages.","title":"For developers"},{"location":"for-developers/#building","text":"A modern C++ toolchain supporting C++20 meson as the build system of choice pandoc if you want to generate the documentation/man pages To build, test and install it you can just use normal meson commands.","title":"Building"},{"location":"for-developers/#using-it","text":"Right now this project is only available as a meson package. I might consider adding cmake later on to gain a wider compatibility.","title":"Using it"},{"location":"for-developers/#versioning","text":"At this time, this repository is only available as a meson package. Releases are tagged on the repo, with master as the main development branch. Semantic versioning will be followed after v1.0.0 . Before that, any release can and will have breaking changes. Versions ending with an odd revision number are meant for proper for releases, while even numbers are only for in-dev stages.","title":"Versioning"},{"location":"manual/","text":"vs-templ is a simple preprocessor for XML files. It can be used statically generate new files from a template definition. Static templates can be seen as extremely simple programs which are interpreted by this preprocessor. They consume input data also formatted as XML, and generate some output XML file. In theory, it is possible for data to be expressed in other formats (eg. JSON) as well, but at the moment this is not a supported feature. CLI # vs.tmpl <template-file> <data-file> [namespace=`s:`] Unlike its usage in vs.fltk, template must be specified on its own. There is also an alternative format: vs.tmpl [namespace=`s:`] with both files added via pipes, like vs.tmpl <(cat template.xml) <(cat data.xml) Syntax quick reference # vs.templ uses special elements and attributes to determine the actions to be performed by the preprocessor. They are scoped under the namespace s , or any custom defined one. This man page only covers a quick syntax reference. If you are looking for the full specs, please check the official repository . Path expressions # Expression are used to access elements and attributes of the data XML from the template. Their definition and usage is purposefully restricted to prevent arbitrary code to be run. A full list of feasible expression types: String, automatically assigned from expressions starting with # (the prefix is skipped) Integers (base 10), automatically assigned from expressions starting with a digit, + , - or . Paths starting with $ . This special symbol is used to mark the nearest scope being visited or root if none. Paths with arbitrary prefix {var-name} where var-name is searched for and resolved from the symbols\u2019 stack. Absolute paths starting from the root, with prefix / . The rest of a path expression has one or more tokens / -terminated representing the tag name being visited. If terminated with ~prop-name the relevant attribute is selected. There are also two special properties: Special access to the property ~!txt to get the node text. Special access to the element\u2019s name via ~!tag No further combination or format is allowed, and if used they might lead to undefined behaviour. However, the preprocessor should not result in exceptions.","title":"Manual"},{"location":"manual/#cli","text":"vs.tmpl <template-file> <data-file> [namespace=`s:`] Unlike its usage in vs.fltk, template must be specified on its own. There is also an alternative format: vs.tmpl [namespace=`s:`] with both files added via pipes, like vs.tmpl <(cat template.xml) <(cat data.xml)","title":"CLI"},{"location":"manual/#syntax-quick-reference","text":"vs.templ uses special elements and attributes to determine the actions to be performed by the preprocessor. They are scoped under the namespace s , or any custom defined one. This man page only covers a quick syntax reference. If you are looking for the full specs, please check the official repository .","title":"Syntax quick reference"},{"location":"manual/#path-expressions","text":"Expression are used to access elements and attributes of the data XML from the template. Their definition and usage is purposefully restricted to prevent arbitrary code to be run. A full list of feasible expression types: String, automatically assigned from expressions starting with # (the prefix is skipped) Integers (base 10), automatically assigned from expressions starting with a digit, + , - or . Paths starting with $ . This special symbol is used to mark the nearest scope being visited or root if none. Paths with arbitrary prefix {var-name} where var-name is searched for and resolved from the symbols\u2019 stack. Absolute paths starting from the root, with prefix / . The rest of a path expression has one or more tokens / -terminated representing the tag name being visited. If terminated with ~prop-name the relevant attribute is selected. There are also two special properties: Special access to the property ~!txt to get the node text. Special access to the element\u2019s name via ~!tag No further combination or format is allowed, and if used they might lead to undefined behaviour. However, the preprocessor should not result in exceptions.","title":"Path expressions"},{"location":"syntax/","text":"Syntax # vs.templ uses special elements and attributes to determine the actions to be performed by the preprocessor. They are scoped under the namespace s , or any custom defined one. Path expressions # Expression are used to access elements and attributes of the data XML from the template. Their definition and usage is purposefully restricted to prevent arbitrary code to be run. A full list of feasible expression types: String, automatically assigned from expressions starting with # (the prefix is skipped) Integers (base 10), automatically assigned from expressions starting with a digit, + , - or . Paths starting with $ . This special symbol is used to mark the nearest scope being visited or root if none. Paths with arbitrary prefix {var-name} where var-name is searched for and resolved from the symbols\u2019 stack. Absolute paths starting from the root, with prefix / . The rest of a path expression has one or more tokens / -terminated representing the tag name being visited. If terminated with ~prop-name the relevant attribute is selected. There are also two special properties: Special access to the property ~!txt to get the node text. Special access to the element\u2019s name via ~!tag No further combination or format is allowed, and if used they might lead to undefined behaviour. However, the preprocessor should not result in exceptions. Examples # Using the following XML file as reference: <hello> <world attribute-a=\"value-0\"> text-0 </world> <!-- The second one will never be visited with paths like /hello/world/--> <world attribute-a=\"value-1\"> text-1 </world> </hello> /hello/world/ is the list of children for the first world element in hello /hello/world~attribute-a is evaluated as value-0 /hello/world~!txt is evaluated as text-0 Assuming a for cycle in /hello/ , its children will be navigated and $~attribute-a will be resolved in value-0 and value-1 . Operators for elements # Operators acting over elements will use information from the current static data sub-path to further generate a parametrized version of what shown in their children on the template tree. for-range # tag is the name of the symbol where the current value will be stored. If empty the default $ is used. from starting value. to final value. step step of increment. It can be negative. If so to<from must hold true. Infinite cycles are detected before execution, in which case no cycle will run. Unlike other for variants, there is no header, footer or empty child. Anything inside a for-range is interpreted as item . for & for-props # To iterate over children and props of an element respectively. Aside from that, they mostly share the same interface. tag the name of the symbol hosting the current XML node pointer. If empty, its default is $ in must be specified and is a path expression filter as an expression in the internal custom language . sort-by (only available for for ) list of comma separated path expressions. Elements will be sorted giving priority from left to right order-by order preference for each field in the sort-by or the only one implicit for for-props . Each entry is a pair type:comparator with type either ASC, DESC or RANDOM. If not provided, comparator is assumed to be the default one. As an alternative comparator we could have a one using . to separate values in tokens, and order them token by token. limit maximum number of entries to be iterated. If 0 all of them will be considered, if positive that or the maximum number, if negative all but that number if possible o no content. offset offset from start (of the filtered and ordered list of children) Both for & for-props support the following list of children. You can use as many instances of them as you want, in any order. header shown at the top of a nonempty container footer shown at the bottom of a nonempty container empty shown if a container is empty item the main body error shown if it was not possible to retrieve items (because of an error in the path) value # To introduce the value of an expression as text content of an element. It accepts a path expression src as argument. By default, it is assumed to be $ . It also supports an additional format argument, but at this stage it has no implementation. element # To generate a new element whose type is determined by a tag expression ns:type . Any other property and child will be preserved. when & is # To perform conditional cut and paste in the final tree based on simple matches between a reference expression and some values. when accepts a single subject property as a path expression. Inside the body of when we have one or more is . Attributes for is : continue default is false . If true it continues checking and executing even after a match. Else it will break. value a path expression to compare against. The order of is elements is important and determines the overall flow. Operators for properties # xxx are used as tags to identify groups under which multiple attributes should be used. for.SUB-ATTR.[prop/value].xxx & for-props.SUB-ATTR.[prop/value].xxx # As prop, attribute variants of for and for-props . They add attributes/values to the node they are defined within. value.SUB-ATTR.xxx # As prop, to introduce the value of an expression as value of a prop xxx . prop.xxx # To generate new props whose name is determined by an expression.","title":"Syntax"},{"location":"syntax/#syntax","text":"vs.templ uses special elements and attributes to determine the actions to be performed by the preprocessor. They are scoped under the namespace s , or any custom defined one.","title":"Syntax"},{"location":"syntax/#path-expressions","text":"Expression are used to access elements and attributes of the data XML from the template. Their definition and usage is purposefully restricted to prevent arbitrary code to be run. A full list of feasible expression types: String, automatically assigned from expressions starting with # (the prefix is skipped) Integers (base 10), automatically assigned from expressions starting with a digit, + , - or . Paths starting with $ . This special symbol is used to mark the nearest scope being visited or root if none. Paths with arbitrary prefix {var-name} where var-name is searched for and resolved from the symbols\u2019 stack. Absolute paths starting from the root, with prefix / . The rest of a path expression has one or more tokens / -terminated representing the tag name being visited. If terminated with ~prop-name the relevant attribute is selected. There are also two special properties: Special access to the property ~!txt to get the node text. Special access to the element\u2019s name via ~!tag No further combination or format is allowed, and if used they might lead to undefined behaviour. However, the preprocessor should not result in exceptions.","title":"Path expressions"},{"location":"syntax/#examples","text":"Using the following XML file as reference: <hello> <world attribute-a=\"value-0\"> text-0 </world> <!-- The second one will never be visited with paths like /hello/world/--> <world attribute-a=\"value-1\"> text-1 </world> </hello> /hello/world/ is the list of children for the first world element in hello /hello/world~attribute-a is evaluated as value-0 /hello/world~!txt is evaluated as text-0 Assuming a for cycle in /hello/ , its children will be navigated and $~attribute-a will be resolved in value-0 and value-1 .","title":"Examples"},{"location":"syntax/#operators-for-elements","text":"Operators acting over elements will use information from the current static data sub-path to further generate a parametrized version of what shown in their children on the template tree.","title":"Operators for elements"},{"location":"syntax/#for-range","text":"tag is the name of the symbol where the current value will be stored. If empty the default $ is used. from starting value. to final value. step step of increment. It can be negative. If so to<from must hold true. Infinite cycles are detected before execution, in which case no cycle will run. Unlike other for variants, there is no header, footer or empty child. Anything inside a for-range is interpreted as item .","title":"for-range"},{"location":"syntax/#for-for-props","text":"To iterate over children and props of an element respectively. Aside from that, they mostly share the same interface. tag the name of the symbol hosting the current XML node pointer. If empty, its default is $ in must be specified and is a path expression filter as an expression in the internal custom language . sort-by (only available for for ) list of comma separated path expressions. Elements will be sorted giving priority from left to right order-by order preference for each field in the sort-by or the only one implicit for for-props . Each entry is a pair type:comparator with type either ASC, DESC or RANDOM. If not provided, comparator is assumed to be the default one. As an alternative comparator we could have a one using . to separate values in tokens, and order them token by token. limit maximum number of entries to be iterated. If 0 all of them will be considered, if positive that or the maximum number, if negative all but that number if possible o no content. offset offset from start (of the filtered and ordered list of children) Both for & for-props support the following list of children. You can use as many instances of them as you want, in any order. header shown at the top of a nonempty container footer shown at the bottom of a nonempty container empty shown if a container is empty item the main body error shown if it was not possible to retrieve items (because of an error in the path)","title":"for &amp; for-props"},{"location":"syntax/#value","text":"To introduce the value of an expression as text content of an element. It accepts a path expression src as argument. By default, it is assumed to be $ . It also supports an additional format argument, but at this stage it has no implementation.","title":"value"},{"location":"syntax/#element","text":"To generate a new element whose type is determined by a tag expression ns:type . Any other property and child will be preserved.","title":"element"},{"location":"syntax/#when-is","text":"To perform conditional cut and paste in the final tree based on simple matches between a reference expression and some values. when accepts a single subject property as a path expression. Inside the body of when we have one or more is . Attributes for is : continue default is false . If true it continues checking and executing even after a match. Else it will break. value a path expression to compare against. The order of is elements is important and determines the overall flow.","title":"when &amp; is"},{"location":"syntax/#operators-for-properties","text":"xxx are used as tags to identify groups under which multiple attributes should be used.","title":"Operators for properties"},{"location":"syntax/#forsub-attrpropvaluexxx-for-propssub-attrpropvaluexxx","text":"As prop, attribute variants of for and for-props . They add attributes/values to the node they are defined within.","title":"for.SUB-ATTR.[prop/value].xxx &amp; for-props.SUB-ATTR.[prop/value].xxx"},{"location":"syntax/#valuesub-attrxxx","text":"As prop, to introduce the value of an expression as value of a prop xxx .","title":"value.SUB-ATTR.xxx"},{"location":"syntax/#propxxx","text":"To generate new props whose name is determined by an expression.","title":"prop.xxx"}]}